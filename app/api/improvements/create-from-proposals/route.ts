/**
 * Create Outcomes from Analysis Proposals API
 *
 * POST /api/improvements/create-from-proposals
 *
 * Creates outcomes directly from the proposals generated by the improvement analyzer.
 * Supports both individual and consolidated creation.
 */

import { NextRequest, NextResponse } from 'next/server';
import {
  createOutcome,
  getAllOutcomes,
  upsertDesignDoc,
} from '@/lib/db/outcomes';
import { createTasksBatch, type CreateTaskInput } from '@/lib/db/tasks';
import { logImprovementCreated } from '@/lib/db/activity';
import type { TaskPhase } from '@/lib/db/schema';

// Constants
const SELF_IMPROVEMENT_OUTCOME_NAME = 'Self-Improvement';

// Types matching the AnalysisResultSummary from lib/analysis/runner.ts
interface ProposedTask {
  title: string;
  description: string;
  priority: number;
}

interface ProposalSummary {
  clusterId: string;
  rootCause: string;
  escalationCount: number;
  problemSummary: string;
  outcomeName: string;
  proposedTasks: ProposedTask[];
  intent: {
    summary: string;
    itemCount: number;
    successCriteria: string[];
  };
  approach: {
    summary: string;
    stepCount: number;
    risks: string[];
  };
}

interface ClusterSummary {
  id: string;
  rootCause: string;
  patternDescription: string;
  problemStatement: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  escalationCount: number;
  triggerTypes: string[];
}

interface CreateFromProposalsRequest {
  /** The proposals to create outcomes from (from analysis result) */
  proposals: ProposalSummary[];
  /** The clusters data (from analysis result) - optional, used for additional context */
  clusters?: ClusterSummary[];
  /** If true, create one consolidated outcome instead of individual ones */
  consolidated?: boolean;
}

interface CreatedOutcomeInfo {
  id: string;
  name: string;
  taskCount: number;
  rootCause: string;
}

interface CreateFromProposalsResponse {
  success: boolean;
  parentOutcomeId: string;
  outcomes: CreatedOutcomeInfo[];
  message: string;
}

/**
 * Find or create the Self-Improvement parent outcome
 */
function findOrCreateSelfImprovementOutcome(): string {
  const allOutcomes = getAllOutcomes();

  const existing = allOutcomes.find(
    o => o.name === SELF_IMPROVEMENT_OUTCOME_NAME && o.parent_id === null
  );

  if (existing) {
    return existing.id;
  }

  const newOutcome = createOutcome({
    name: SELF_IMPROVEMENT_OUTCOME_NAME,
    brief: 'System-wide improvements derived from escalation pattern analysis',
    intent: JSON.stringify({
      summary: 'Continuously improve the system by addressing recurring escalation patterns',
      items: [],
      success_criteria: [
        'Reduce frequency of common escalation triggers',
        'Improve clarity of outcome specifications',
        'Build skills to handle recurring ambiguities',
      ],
    }),
    is_ongoing: true,
  });

  upsertDesignDoc(newOutcome.id, JSON.stringify({
    summary: 'Automated self-improvement through escalation analysis',
    approach: [
      'Analyze escalation patterns to identify recurring issues',
      'Create child outcomes for each significant pattern',
      'Implement fixes through skills, documentation, or process changes',
      'Measure impact by tracking escalation frequency reduction',
    ],
    technologies: ['HOMÐ¯ Protocol', 'Escalation Analytics'],
    decisions: [],
    version: 1,
  }));

  return newOutcome.id;
}

/**
 * Create an individual outcome from a single proposal
 */
function createOutcomeFromProposal(
  parentId: string,
  proposal: ProposalSummary
): CreatedOutcomeInfo {
  // Generate intent JSON
  const intentJson = JSON.stringify({
    summary: proposal.intent.summary,
    items: proposal.proposedTasks.map((task, index) => ({
      id: String(index + 1),
      title: task.title,
      description: task.description,
      priority: task.priority <= 20 ? 'high' : task.priority <= 40 ? 'medium' : 'low',
      status: 'pending',
    })),
    success_criteria: proposal.intent.successCriteria,
  });

  // Generate approach JSON
  const approachJson = JSON.stringify({
    summary: proposal.approach.summary,
    approach: [
      '1. Analyze the root cause and affected areas',
      '2. Design and implement the fix',
      '3. Test and validate the improvement',
      '4. Monitor for recurrence',
    ],
    risks: proposal.approach.risks,
    version: 1,
  });

  // Create the outcome
  const outcome = createOutcome({
    name: proposal.outcomeName,
    parent_id: parentId,
    brief: proposal.problemSummary,
    intent: intentJson,
    is_ongoing: false,
  });

  // Add design doc
  upsertDesignDoc(outcome.id, approachJson);

  // Create tasks
  const executionPhase: TaskPhase = 'execution';
  const tasks: CreateTaskInput[] = proposal.proposedTasks.map((task, index) => ({
    outcome_id: outcome.id,
    title: task.title,
    description: task.description,
    priority: task.priority || (index + 1) * 10,
    phase: executionPhase,
    task_intent: `Part of fixing: ${proposal.rootCause}`,
    task_approach: proposal.approach.summary,
  }));

  const createdTasks = createTasksBatch(tasks);

  // Log to activity feed
  logImprovementCreated(
    parentId,
    SELF_IMPROVEMENT_OUTCOME_NAME,
    proposal.outcomeName,
    createdTasks.length,
    proposal.escalationCount
  );

  return {
    id: outcome.id,
    name: proposal.outcomeName,
    taskCount: createdTasks.length,
    rootCause: proposal.rootCause,
  };
}

/**
 * Create a consolidated outcome from multiple proposals
 */
function createConsolidatedOutcome(
  parentId: string,
  proposals: ProposalSummary[]
): CreatedOutcomeInfo {
  const totalEscalations = proposals.reduce((sum, p) => sum + p.escalationCount, 0);
  const outcomeName = proposals.length === 1
    ? proposals[0].outcomeName
    : `System Improvements (${proposals.length} patterns, ${totalEscalations} escalations)`;

  // Combine all success criteria
  const allSuccessCriteria = proposals.flatMap(p => p.intent.successCriteria);
  const uniqueSuccessCriteria = Array.from(new Set(allSuccessCriteria)).slice(0, 6);

  // Combine all risks
  const allRisks = proposals.flatMap(p => p.approach.risks);
  const uniqueRisks = Array.from(new Set(allRisks)).slice(0, 4);

  // Generate consolidated intent
  const intentJson = JSON.stringify({
    summary: `Address ${proposals.length} recurring escalation patterns (${totalEscalations} total escalations)`,
    items: proposals.map((p, index) => ({
      id: String(index + 1),
      title: `Fix: ${p.rootCause}`,
      description: p.problemSummary,
      priority: p.escalationCount > 5 ? 'high' : 'medium',
      status: 'pending',
    })),
    success_criteria: uniqueSuccessCriteria.length > 0 ? uniqueSuccessCriteria : [
      'Reduce overall escalation frequency by 30%',
      'Create reusable skills for handling common ambiguities',
    ],
  });

  // Generate consolidated approach
  const approachJson = JSON.stringify({
    summary: `Consolidated approach to address ${proposals.length} escalation patterns`,
    approach: [
      '1. Analysis Phase: Review all historical escalations for each pattern',
      '2. Root Cause Identification: Extract common themes across patterns',
      '3. Solution Design: Create skills, templates, and documentation',
      '4. Implementation: Deploy changes and update affected outcomes',
      '5. Validation: Monitor escalation frequency and measure improvement',
    ],
    patterns: proposals.map(p => p.rootCause),
    risks: uniqueRisks,
    version: 1,
  });

  // Create the outcome
  const outcome = createOutcome({
    name: outcomeName,
    parent_id: parentId,
    brief: `Consolidated improvement addressing ${proposals.length} recurring escalation patterns`,
    intent: intentJson,
    is_ongoing: false,
  });

  // Add design doc
  upsertDesignDoc(outcome.id, approachJson);

  // Create tasks from all proposals
  const executionPhase: TaskPhase = 'execution';
  const tasks: CreateTaskInput[] = [];
  let priority = 10;

  for (const proposal of proposals) {
    for (const task of proposal.proposedTasks) {
      tasks.push({
        outcome_id: outcome.id,
        title: task.title,
        description: `${task.description}\n\nRoot cause: ${proposal.rootCause}`,
        priority: priority,
        phase: executionPhase,
        task_intent: `Part of fixing: ${proposal.rootCause}`,
        task_approach: proposal.approach.summary,
      });
      priority += 10;
    }
  }

  const createdTasks = createTasksBatch(tasks);

  // Log to activity feed
  logImprovementCreated(
    parentId,
    SELF_IMPROVEMENT_OUTCOME_NAME,
    outcomeName,
    createdTasks.length,
    totalEscalations
  );

  return {
    id: outcome.id,
    name: outcomeName,
    taskCount: createdTasks.length,
    rootCause: proposals.map(p => p.rootCause).join(', '),
  };
}

export async function POST(request: NextRequest): Promise<NextResponse> {
  try {
    const body = (await request.json()) as CreateFromProposalsRequest;

    // Validate input
    if (!body.proposals || !Array.isArray(body.proposals) || body.proposals.length === 0) {
      return NextResponse.json(
        { error: 'proposals array is required and must not be empty' },
        { status: 400 }
      );
    }

    // Find or create the Self-Improvement parent outcome
    const parentOutcomeId = findOrCreateSelfImprovementOutcome();

    const createdOutcomes: CreatedOutcomeInfo[] = [];

    if (body.consolidated) {
      // Create one consolidated outcome
      const outcome = createConsolidatedOutcome(parentOutcomeId, body.proposals);
      createdOutcomes.push(outcome);
    } else {
      // Create individual outcomes for each proposal
      for (const proposal of body.proposals) {
        const outcome = createOutcomeFromProposal(parentOutcomeId, proposal);
        createdOutcomes.push(outcome);
      }
    }

    const totalTasks = createdOutcomes.reduce((sum, o) => sum + o.taskCount, 0);

    const response: CreateFromProposalsResponse = {
      success: true,
      parentOutcomeId,
      outcomes: createdOutcomes,
      message: body.consolidated
        ? `Created 1 consolidated outcome with ${totalTasks} tasks`
        : `Created ${createdOutcomes.length} outcome(s) with ${totalTasks} total tasks`,
    };

    return NextResponse.json(response);
  } catch (error) {
    console.error('Error creating outcomes from proposals:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'Failed to create outcomes from proposals',
        details: error instanceof Error ? error.message : 'Unknown error',
      },
      { status: 500 }
    );
  }
}
