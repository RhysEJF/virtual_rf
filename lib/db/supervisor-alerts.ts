/**
 * Supervisor Alerts CRUD operations
 *
 * Supervisor alerts are generated by the monitoring system to flag
 * workers that are stuck, not making progress, or encountering repeated errors.
 */

import { getDb, now } from './index';
import type {
  SupervisorAlert,
  SupervisorAlertType,
  SupervisorAlertSeverity,
  SupervisorAlertStatus,
} from './schema';

// ============================================================================
// Create
// ============================================================================

export interface CreateSupervisorAlertInput {
  worker_id: string;
  outcome_id: string;
  type: SupervisorAlertType;
  severity: SupervisorAlertSeverity;
  message: string;
  auto_paused?: boolean;
}

export function createSupervisorAlert(input: CreateSupervisorAlertInput): SupervisorAlert {
  const db = getDb();
  const timestamp = now();

  const stmt = db.prepare(`
    INSERT INTO supervisor_alerts (
      worker_id, outcome_id, type, severity, message, status, auto_paused, created_at
    )
    VALUES (?, ?, ?, ?, ?, 'active', ?, ?)
  `);

  const result = stmt.run(
    input.worker_id,
    input.outcome_id,
    input.type,
    input.severity,
    input.message,
    input.auto_paused ? 1 : 0,
    timestamp
  );

  return getSupervisorAlertById(result.lastInsertRowid as number)!;
}

// ============================================================================
// Read
// ============================================================================

export function getSupervisorAlertById(id: number): SupervisorAlert | null {
  const db = getDb();
  const row = db.prepare('SELECT * FROM supervisor_alerts WHERE id = ?').get(id) as SupervisorAlert | undefined;
  if (!row) return null;
  return {
    ...row,
    auto_paused: Boolean(row.auto_paused),
  };
}

export function getActiveAlerts(): SupervisorAlert[] {
  const db = getDb();
  const rows = db.prepare(`
    SELECT * FROM supervisor_alerts
    WHERE status = 'active'
    ORDER BY
      CASE severity WHEN 'critical' THEN 0 ELSE 1 END,
      created_at DESC
  `).all() as SupervisorAlert[];

  return rows.map(row => ({
    ...row,
    auto_paused: Boolean(row.auto_paused),
  }));
}

export function getAlertsByWorker(workerId: string, status?: SupervisorAlertStatus): SupervisorAlert[] {
  const db = getDb();

  if (status) {
    const rows = db.prepare(`
      SELECT * FROM supervisor_alerts
      WHERE worker_id = ? AND status = ?
      ORDER BY created_at DESC
    `).all(workerId, status) as SupervisorAlert[];

    return rows.map(row => ({
      ...row,
      auto_paused: Boolean(row.auto_paused),
    }));
  }

  const rows = db.prepare(`
    SELECT * FROM supervisor_alerts
    WHERE worker_id = ?
    ORDER BY created_at DESC
  `).all(workerId) as SupervisorAlert[];

  return rows.map(row => ({
    ...row,
    auto_paused: Boolean(row.auto_paused),
  }));
}

export function getAlertsByOutcome(outcomeId: string, status?: SupervisorAlertStatus): SupervisorAlert[] {
  const db = getDb();

  if (status) {
    const rows = db.prepare(`
      SELECT * FROM supervisor_alerts
      WHERE outcome_id = ? AND status = ?
      ORDER BY created_at DESC
    `).all(outcomeId, status) as SupervisorAlert[];

    return rows.map(row => ({
      ...row,
      auto_paused: Boolean(row.auto_paused),
    }));
  }

  const rows = db.prepare(`
    SELECT * FROM supervisor_alerts
    WHERE outcome_id = ?
    ORDER BY created_at DESC
  `).all(outcomeId) as SupervisorAlert[];

  return rows.map(row => ({
    ...row,
    auto_paused: Boolean(row.auto_paused),
  }));
}

export function getRecentAlerts(limit: number = 20): SupervisorAlert[] {
  const db = getDb();
  const rows = db.prepare(`
    SELECT * FROM supervisor_alerts
    ORDER BY created_at DESC
    LIMIT ?
  `).all(limit) as SupervisorAlert[];

  return rows.map(row => ({
    ...row,
    auto_paused: Boolean(row.auto_paused),
  }));
}

/**
 * Check if there's already an active alert of the same type for a worker.
 * Used to avoid duplicate alerts.
 */
export function hasActiveAlertOfType(workerId: string, type: SupervisorAlertType): boolean {
  const db = getDb();
  const result = db.prepare(`
    SELECT 1 FROM supervisor_alerts
    WHERE worker_id = ? AND type = ? AND status = 'active'
    LIMIT 1
  `).get(workerId, type);

  return result !== undefined;
}

// ============================================================================
// Update
// ============================================================================

export function acknowledgeAlert(id: number): SupervisorAlert | null {
  const db = getDb();
  const timestamp = now();

  db.prepare(`
    UPDATE supervisor_alerts
    SET status = 'acknowledged', acknowledged_at = ?
    WHERE id = ? AND status = 'active'
  `).run(timestamp, id);

  return getSupervisorAlertById(id);
}

export function resolveAlert(id: number): SupervisorAlert | null {
  const db = getDb();
  const timestamp = now();

  db.prepare(`
    UPDATE supervisor_alerts
    SET status = 'resolved', resolved_at = ?
    WHERE id = ? AND status IN ('active', 'acknowledged')
  `).run(timestamp, id);

  return getSupervisorAlertById(id);
}

export function resolveAlertsForWorker(workerId: string): number {
  const db = getDb();
  const timestamp = now();

  const result = db.prepare(`
    UPDATE supervisor_alerts
    SET status = 'resolved', resolved_at = ?
    WHERE worker_id = ? AND status IN ('active', 'acknowledged')
  `).run(timestamp, workerId);

  return result.changes;
}

// ============================================================================
// Stats
// ============================================================================

export function getAlertStats(): {
  total: number;
  active: number;
  acknowledged: number;
  resolved: number;
  critical_active: number;
} {
  const db = getDb();

  const rows = db.prepare(`
    SELECT status, severity, COUNT(*) as count
    FROM supervisor_alerts
    GROUP BY status, severity
  `).all() as { status: SupervisorAlertStatus; severity: SupervisorAlertSeverity; count: number }[];

  const stats = {
    total: 0,
    active: 0,
    acknowledged: 0,
    resolved: 0,
    critical_active: 0,
  };

  for (const row of rows) {
    stats.total += row.count;
    stats[row.status] += row.count;
    if (row.status === 'active' && row.severity === 'critical') {
      stats.critical_active += row.count;
    }
  }

  return stats;
}
